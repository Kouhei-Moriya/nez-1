package nez.generator;

import java.util.ArrayList;
import java.util.HashMap;

import nez.Parser;
import nez.ast.SymbolId;
import nez.lang.Expression;
import nez.lang.Production;
import nez.lang.Typestate;
import nez.lang.expr.Uand;
import nez.lang.expr.Cany;
import nez.lang.expr.Xblock;
import nez.lang.expr.Cbyte;
import nez.lang.expr.Cset;
import nez.lang.expr.Tcapture;
import nez.lang.expr.Choice;
import nez.lang.expr.Xdefindent;
import nez.lang.expr.Xdef;
import nez.lang.expr.Xexists;
import nez.lang.expr.Xindent;
import nez.lang.expr.Xis;
import nez.lang.expr.Tlink;
import nez.lang.expr.Xlocal;
import nez.lang.expr.Xmatch;
import nez.lang.expr.Cmulti;
import nez.lang.expr.Tnew;
import nez.lang.expr.NonTerminal;
import nez.lang.expr.Unot;
import nez.lang.expr.Uoption;
import nez.lang.expr.Uzero;
import nez.lang.expr.Uone;
import nez.lang.expr.Treplace;
import nez.lang.expr.Sequence;
import nez.lang.expr.Ttag;
import nez.util.StringUtils;

public class JavaParserGenerator extends ParserGenerator {

	@Override
	public String getDesc() {
		return "a Nez parser generator for Java (sample)";
	}

	@Override
	public void makeHeader(Parser g) {
		W("/* The following is generated by the Nez Grammar Generator */");
		L("class P").Begin();
	}

	@Override
	public void makeFooter(Parser g) {
		End();
	}

	String _func(Production rule) {
		return rule.getLocalName();
	}

	String _func(Expression e) {
		return "e" + e.getId();
	}

	String _ctx() {
		return "c";
	}

	String _call(Production p) {
		return _func(p) + "(" + _ctx() + ")";
	}

	String _call(Expression e) {
		ensureFunc(e);
		return "e" + e.getId() + "(" + _ctx() + ")";
	}

	String _not(String expr) {
		return "!(" + expr + ")";
	}

	String _true() {
		return "true";
	}

	String _false() {
		return "false";
	}

	String _left() {
		return "left";
	}

	String _log() {
		return "log";
	}

	String _cref(String n) {
		return _ctx() + "." + n + "()";
	}

	String _ccall(String n) {
		return _ctx() + "." + n + "()";
	}

	String _ccall(String n, String a) {
		return _ctx() + "." + n + "(" + a + ")";
	}

	String _ccall(String n, String a, String a2) {
		return _ctx() + "." + n + "(" + a + "," + a2 + ")";
	}

	String _cleft() {
		return _cref("left");
	}

	String _clog() {
		return _cref("log");
	}

	JavaParserGenerator VarNode(String n, String left) {
		L("Object " + n + " = " + left).Semi();
		return this;
	}

	JavaParserGenerator Commit(String log, String left) {
		Return(_ctx() + ".commit(" + log + ", " + left + ")");
		return this;
	}

	JavaParserGenerator Abort(String log, String left) {
		Return(_ctx() + ".abort(" + log + ", " + left + ")");
		return this;
	}

	String _match(int c) {
		return _ccall("byte", "" + c);
	}

	String _match(boolean[] b) {
		return _ccall("byte", "" + b);
	}

	String _match() {
		return _ccall("any");
	}

	String _result() {
		return "result";
	}

	String _pos() {
		return "pos";
	}

	String _cpos() {
		return _cref("pos");
	}

	String _eq(String v, String v2) {
		return "(" + v + " == " + v2 + ")";
	}

	protected JavaParserGenerator Save(Expression e) {
		VarInt(_pos(), _cpos());
		if (e.inferTypestate() != Typestate.BooleanType) {
			VarInt(_log(), _clog());
		}
		return this;
	}

	protected JavaParserGenerator Rollback(Expression e) {
		if (e.inferTypestate() != Typestate.BooleanType) {
			Statement(_ccall("abort", _log()));
		}
		Statement(_ccall("setpos", _pos()));
		return this;
	}

	protected JavaParserGenerator W(String word) {
		file.write(word);
		return this;
	}

	protected JavaParserGenerator L() {
		file.writeIndent();
		return this;
	}

	protected JavaParserGenerator inc() {
		file.incIndent();
		return this;
	}

	protected JavaParserGenerator dec() {
		file.decIndent();
		return this;
	}

	protected JavaParserGenerator L(String line) {
		file.writeIndent(line);
		return this;
	}

	protected JavaParserGenerator DefPublicFunc(String name) {
		L("public static boolean ").W(name).W(" (NezContext ").W(_ctx()).W(") ");
		return this;
	}

	protected JavaParserGenerator DefFunc(String name) {
		L("private static boolean ").W(name).W(" (NezContext ").W(_ctx()).W(") ");
		return this;
	}

	protected JavaParserGenerator FuncName(Expression e) {
		W("e" + e.getId());
		return this;
	}

	protected JavaParserGenerator IfThen(String c) {
		L("if (").W(c).W(") ");
		return this;
	}

	protected JavaParserGenerator IfNotThen(String c) {
		L("if (").W(_not(c)).W(") ");
		return this;
	}

	protected JavaParserGenerator Else() {
		L("else");
		return this;
	}

	protected JavaParserGenerator Begin() {
		W("{").inc();
		return this;
	}

	protected JavaParserGenerator End() {
		dec().L("}");
		return this;
	}

	protected JavaParserGenerator While(String c) {
		L("while (").W(c).W(") ");
		return this;
	}

	protected JavaParserGenerator Continue() {
		L("continue").Semi();
		return this;
	}

	protected JavaParserGenerator Break() {
		L("break").Semi();
		return this;
	}

	protected JavaParserGenerator VarInt(String n, String v) {
		L("int ").W(n).W(" = ").W(v).Semi();
		return this;
	}

	protected JavaParserGenerator VarBool(String n, String v) {
		L("boolean ").W(n).W(" = ").W(v).Semi();
		return this;
	}

	protected JavaParserGenerator Assign(String n, String v) {
		L(n).W(" = ").W(v).Semi();
		return this;
	}

	protected JavaParserGenerator Semi() {
		W(";");
		return this;
	}

	protected JavaParserGenerator Statement(String expr) {
		L(expr).Semi();
		return this;
	}

	protected JavaParserGenerator Return(String v) {
		L("return ").W(v).Semi();
		return this;
	}

	protected JavaParserGenerator Comment(Object s) {
		W("/* ").W(s.toString()).W(" */");
		return this;
	}

	protected JavaParserGenerator LComment(Object s) {
		L("// ").W(s.toString());
		return this;
	}

	public void writeLinkLogic(Tlink e) {
		VarNode(_left(), _cleft());
		VarInt(_log(), _clog());
		IfThen(_call(e.get(0))).Begin().Commit(_log(), _left()).End();
		Abort(_log(), _left());
	}

	HashMap<String, Object> funcMap = new HashMap<String, Object>();

	private void ensureFunc(Expression e) {
		String key = _func(e);
		if (!funcMap.containsKey(key)) {
			funcMap.put(key, e);
		}
	}

	private void makeFunc() {
		ArrayList<Expression> l = new ArrayList<Expression>(funcMap.size());
		for (String key : funcMap.keySet()) {
			Object o = funcMap.get(key);
			if (o instanceof Expression) {
				l.add((Expression) o);
				funcMap.put(key, key);
			}
		}
		for (Expression e : l) {
			writeFunc(e);
		}
	}

	private void writeFunc(Expression e) {
		DefFunc(_func(e));
		Begin();
		Comment(e);
		if (e instanceof Choice) {
			writeChoiceLogic(e);
		} else if (e instanceof Tlink) {
			writeLinkLogic((Tlink) e);
		} else if (e instanceof Uoption) {
			writeOptionLogic(e);
		} else if (e instanceof Uzero || e instanceof Uone) {
			writeRepetitionLogic(e);
		} else if (e instanceof Unot || e instanceof Uand) {
			writePredicateLogic(e);
		} else {
			visitExpression(e);
			Return(_true());
		}
		End();
		makeFunc();
	}

	private void writeOptionLogic(Expression e) {
		Save(e.get(0));
		IfThen(_call(e.get(0))).Begin().Return(_true()).End();
		Rollback(e.get(0));
		Return(_true());
	}

	private void writeRepetitionLogic(Expression e) {
		While(_true()).Begin();
		Save(e.get(0));
		ensureFunc(e.get(0));
		IfThen(_call(e.get(0))).Begin();
		IfThen(_eq(_pos(), _cpos())).Begin().Break().End();
		Continue();
		End();
		Rollback(e.get(0));
		Break();
		End();
		Return(_true());
	}

	private void writeChoiceLogic(Expression e) {
		Save(e);
		for (Expression s : e) {
			IfThen(_call(s)).Begin().Return(_true()).End();
			Rollback(e);
		}
		Return(_false());
		;
	}

	private void writePredicateLogic(Expression e) {
		Save(e.get(0));
		VarBool(_result(), _call(e.get(0)));
		Rollback(e.get(0));
		Return(_result());
	}

	@Override
	public void visitProduction(Production rule) {
		DefPublicFunc(_func(rule)).Begin();
		visitExpression(rule.getExpression());
		Return(_true());
		End();
		makeFunc();
	}

	@Override
	public void visitEmpty(Expression e) {

	}

	@Override
	public void visitFailure(Expression e) {
		Return(_false());
	}

	@Override
	public void visitNonTerminal(NonTerminal e) {
		IfThen(_not(_call(e.getProduction()))).Begin().Return(_false()).End();
	}

	@Override
	public void visitByteChar(Cbyte e) {
		IfNotThen(_match(e.byteChar)).Begin().Return(_false()).End();
	}

	@Override
	public void visitByteMap(Cset e) {
		IfNotThen(_match(e.byteMap)).Begin().Return(_false()).End();
	}

	@Override
	public void visitAnyChar(Cany e) {
		IfNotThen(_match()).Begin().Return(_false()).End();
	}

	@Override
	public void visitCharMultiByte(Cmulti p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitOption(Uoption e) {
		Statement(_call(e));
	}

	@Override
	public void visitRepetition(Uzero e) {
		Statement(_call(e));
	}

	@Override
	public void visitRepetition1(Uone e) {
		visitExpression(e.get(0));
		Statement(_call(e));
	}

	@Override
	public void visitAnd(Uand e) {
		IfNotThen(_call(e)).Begin().Return(_false()).End();
	}

	@Override
	public void visitNot(Unot e) {
		IfThen(_call(e)).Begin().Return(_false()).End();
	}

	@Override
	public void visitSequence(Sequence e) {
		for (Expression s : e) {
			visitExpression(s);
		}
	}

	@Override
	public void visitChoice(Choice e) {
		IfNotThen(_call(e)).Begin().Return(_false()).End();
	}

	@Override
	public void visitNew(Tnew e) {
		Statement(_ccall("new"));
	}

	@Override
	public void visitCapture(Tcapture e) {
		Statement(_ccall("capture"));
	}

	protected String _tag(SymbolId tag) {
		return StringUtils.quoteString('"', tag.getSymbol(), '"');
	}

	@Override
	public void visitTagging(Ttag e) {
		Statement(_ccall("tag", _tag(e.tag)));
	}

	@Override
	public void visitReplace(Treplace e) {
		Statement(_ccall("replace", StringUtils.quoteString('"', e.value, '"')));
	}

	@Override
	public void visitLink(Tlink e) {
		IfNotThen(_call(e)).Begin().Return(_false()).End();
	}

	@Override
	public void visitUndefined(Expression e) {
		LComment("undefined " + e);
	}

	@Override
	public void visitExpression(Expression e) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitBlock(Xblock p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitDefSymbol(Xdef p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitIsSymbol(Xis p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitMatchSymbol(Xmatch p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitDefIndent(Xdefindent p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitIsIndent(Xindent p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitExistsSymbol(Xexists p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitLocalTable(Xlocal p) {
		// TODO Auto-generated method stub

	}

}
